Partner 1: Jacob Lin (Shu-Hung Lin)
Login: cs61c-apf

Partner 2: Tina Tu
Login: cs61c-aqi

1. The potential problem would be that there are too many solutions to be generated in the solution set. For example, in a 5X5 board, if the solution predicate is that '1' has to be in the top left corner, there would be 24! children to be generated by doing the permutation on the remaining 24 grids, which is too many to store.

2. A better algorithm would be to pass in the initial board configuration into BFS to generate all children.  As we are going through the children, we would have a conditional in which we check to see if the child satsifies the solution predicate, thus revealing that the child is a solution.  If it is a solution, the child would then be set to level 0 and added to the solution list for the next iteration of BFS, thus we are only running BFS on the children that are solutions instead of all the children which would possibly create an almost endless list.

3. Rather than the distance to the solution, we would instead store the current node's parent so that in the map function of our solver we could check to see if it's a repeated move by comparing the current node to its parent's parent, meaning grandparent. If the current node is equal to its grandparent, we exclude it, thus reducing the chance of an infinite loop where a move is going back and forth and the number of boards (memory requirements) to store in the solution list. In addition, in the reduce function, instead of only selecting the lowest level which is now changed to be a parent node, we would output all the (K, V) pairs but what we only care is the Key, which is the non-repeated children generated by each iteration of map and reduce. In the end, we check to see if our solution list contains the specified solution by the specific game. If it does contain the specified solution, it means it can achieve the solution. If not, it means that the given starting board will reach a dead end eventually. However, in the case of Peg Solitaire, the memory requirements would not change since every move creates a different board by eliminating one peg each time, thus already eliminating the chance of going back and forth automatically.